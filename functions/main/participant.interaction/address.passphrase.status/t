;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;
;   ./functions/main/participant.interaction/address.passphrase.status/t
;
;   This code performs detailed processing of data received from sockets with the 'passphrase' status. Essentially, it assumes the received data is intended to represent a passphrase, and
;   compares the data to the stored passphrase for the user. If they match, then the user's status is set to 'active' and control is passed back to the caller. If they do not match, then the
;   user is informed of the situation and disconnected.
;
;   Assumptions:    Stack Frame:  dword [Connection ID to be addressed]
;                                 dword [Pointer to connection filename]
;
;   Returns:        None.
;
;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
;
;   Symbolic Cross-Referencing
;
;   No external references.
;

    address.passphrase.status:                        mov   ebp, esp                                                      ; ebp - Prepared to be used as a data pointer.
                                                      add   ebp, aps.packet                                               ; ebp - Data pointer.

                                                      call  recv.from.socket                                              ; Grab the data from the socket.

                                                      mov   ecx, eax                                                      ; ecx - Number of bytes read.

                                                      mov   esi, buffer.1                                                 ; Pointer to received data.

                                                      cmp   dword [ebp + aps.packet.filename], egg.filename               ; Are we dealing with an egg?
                                                      jz    address.passphrase.status.eggs                                ; Yes. Go deal with eggs.

                                                      cmp   dword [ebp + aps.packet.filename], gylf.filename              ; Are we dealing with a gylf?
                                                      jz    address.passphrase.status.gylf                                ; Yes. Go deal with gylf.
                              
    address.passphrase.status.ghosts:                 mov   edi, (d.data + ghost.passphrase)                              ; edi - Pointer to ghost passphrase.
                                                      jmp   address.passphrase.status.edi.positioned                      ; Continue with the comparison.

    address.passphrase.status.eggs:                   mov   edi, (e.data + ghost.passphrase)                              ; edi - Pointer to egg passphrase.
                                                      jmp   address.passphrase.status.edi.positioned                      ; Continue with the comparison.

    address.passphrase.status.gylf:                   mov   edi, (g.data + gylf.passphrase)                               ; edi - Pointer to gylf passphrase.

    address.passphrase.status.edi.positioned:         repz  cmpsb                                                         ; Is the passphrase good?
                                                      jcxz  address.passphrase.status.good.passphrase                     ; Yes. Go set the connection status and let the user in.

                                                      push  dword [text.data.index.socket.data.bad.passphrase.message]    ; Point send function to message indicating that the passphrase was bad.
					                                            call	socket.send									                                  ; Tell the user that he's SOL.

              					                              call	clean.socket									                                ; Smoke that connection!

    address.passphrase.status.done:                   ret   aps.packet                                                    ; Return to caller.

    address.passphrase.status.good.passphrase:        push  dword [ebp + aps.packet.filename]                             ; Point open.descriptor to socket credential filename.
                                                      call  open.descriptor                                               ; Associate a descriptor with the credential.

                                                      push  eax                                                           ; Preserve descriptor for close.descriptor.
                                                      push  eax                                                           ; Preserve descriptor for conditional credential update.

                                                      cmp   dword [ebp + aps.packet.filename], egg.filename               ; Are we dealing with an egg?
                                                      jz    address.passphrase.status.good.passphrase.eggs                ; Yes. Go deal with eggs.

                                                      cmp   dword [ebp + aps.packet.filename], gylf.filename              ; Are we dealing with a gylf?
                                                      jz    address.passphrase.status.good.passphrase.gylf                ; Yes. Go deal with gylf.
                              
    address.passphrase.status.good.passphrase.ghosts: mov   byte [d.data + ghost.connection.status.index], active.status  ; Set the status of the connection to 'active'.

                                                      push  d.data                                                        ; Point write.descriptor to d.data.
                                                      push  ghost_size                                                    ; Tell write.descriptor to write an entire ghost credential.

                                                      jmp   address.passphrase.status.update.credential                   ; Go update the credential.

    address.passphrase.status.good.passphrase.eggs:   mov   byte [e.data + egg.connection.status.index], active.status    ; Set the status of the connection to 'active'.

                                                      push  e.data                                                        ; Point write.descriptor to e.data.
                                                      push  egg_size                                                      ; Tell write.descriptor to write an entire egg credential.

                                                      jmp   address.passphrase.status.update.credential                   ; Go update the credential.

    address.passphrase.status.good.passphrase.gylf:   mov   byte [g.data + gylf.connection.status.index], active.status   ; Set the status of the connection to 'active'.

                                                      push  g.data                                                        ; Point write.descriptor to g.data.
                                                      push  gylf_size                                                     ; Tell write.descriptor to write an entire gylf credential.

    address.passphrase.status.update.credential:      call  write.descriptor                                              ; Update the credential.
                                                      call  close.descriptor                                              ; Disassociate the descriptor.

                                            					call	write.welcome									                                ; Print the welcome screen.

                                                      jmp   address.passphrase.status.done                                ; Go return to caller.
